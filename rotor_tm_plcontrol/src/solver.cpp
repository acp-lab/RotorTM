/* This file was automatically generated by CasADi 3.6.7.
 *  It consists of: 
 *   1) content generated by CasADi runtime: not copyrighted
 *   2) template code copied from CasADi source: permissively licensed (MIT-0)
 *   3) user code: owned by the user
 *
 */
#ifdef __cplusplus
extern "C" {
#endif

/* How to prefix internal symbols */
#ifdef CASADI_CODEGEN_PREFIX
  #define CASADI_NAMESPACE_CONCAT(NS, ID) _CASADI_NAMESPACE_CONCAT(NS, ID)
  #define _CASADI_NAMESPACE_CONCAT(NS, ID) NS ## ID
  #define CASADI_PREFIX(ID) CASADI_NAMESPACE_CONCAT(CODEGEN_PREFIX, ID)
#else
  #define CASADI_PREFIX(ID) solver_ ## ID
#endif

#include <math.h>
#include <coin-or/IpStdCInterface.h>

#ifndef casadi_real
#define casadi_real double
#endif

#ifndef casadi_int
#define casadi_int long long int
#endif

#ifndef CASADI_MAX_NUM_THREADS
#define CASADI_MAX_NUM_THREADS 1
#endif

/* Add prefix to internal symbols */
#define casadi_c0 CASADI_PREFIX(c0)
#define casadi_c1 CASADI_PREFIX(c1)
#define casadi_c2 CASADI_PREFIX(c2)
#define casadi_c3 CASADI_PREFIX(c3)
#define casadi_clear CASADI_PREFIX(clear)
#define casadi_copy CASADI_PREFIX(copy)
#define casadi_f0 CASADI_PREFIX(f0)
#define casadi_f1 CASADI_PREFIX(f1)
#define casadi_f1_alloc_mem CASADI_PREFIX(f1_alloc_mem)
#define casadi_f1_init_mem CASADI_PREFIX(f1_init_mem)
#define casadi_f1_mem CASADI_PREFIX(f1_mem)
#define casadi_f1_mem_counter CASADI_PREFIX(f1_mem_counter)
#define casadi_f1_unused_stack CASADI_PREFIX(f1_unused_stack)
#define casadi_f1_unused_stack_counter CASADI_PREFIX(f1_unused_stack_counter)
#define casadi_f2 CASADI_PREFIX(f2)
#define casadi_f3 CASADI_PREFIX(f3)
#define casadi_f4 CASADI_PREFIX(f4)
#define casadi_f5 CASADI_PREFIX(f5)
#define casadi_f6 CASADI_PREFIX(f6)
#define casadi_f7 CASADI_PREFIX(f7)
#define casadi_fill CASADI_PREFIX(fill)
#define casadi_fmax CASADI_PREFIX(fmax)
#define casadi_ipopt_data CASADI_PREFIX(ipopt_data)
#define casadi_ipopt_free_mem CASADI_PREFIX(ipopt_free_mem)
#define casadi_ipopt_hess_l_empty CASADI_PREFIX(ipopt_hess_l_empty)
#define casadi_ipopt_init CASADI_PREFIX(ipopt_init)
#define casadi_ipopt_init_mem CASADI_PREFIX(ipopt_init_mem)
#define casadi_ipopt_presolve CASADI_PREFIX(ipopt_presolve)
#define casadi_ipopt_setup CASADI_PREFIX(ipopt_setup)
#define casadi_ipopt_solve CASADI_PREFIX(ipopt_solve)
#define casadi_ipopt_sparsity CASADI_PREFIX(ipopt_sparsity)
#define casadi_ipopt_work CASADI_PREFIX(ipopt_work)
#define casadi_mtimes CASADI_PREFIX(mtimes)
#define casadi_nlp_f0 CASADI_PREFIX(nlp_f0)
#define casadi_nlp_g0 CASADI_PREFIX(nlp_g0)
#define casadi_nlp_grad_f0 CASADI_PREFIX(nlp_grad_f0)
#define casadi_nlp_hess_l0 CASADI_PREFIX(nlp_hess_l0)
#define casadi_nlp_jac_g0 CASADI_PREFIX(nlp_jac_g0)
#define casadi_nlpsol_data CASADI_PREFIX(nlpsol_data)
#define casadi_nlpsol_detect_bounds_after CASADI_PREFIX(nlpsol_detect_bounds_after)
#define casadi_nlpsol_detect_bounds_before CASADI_PREFIX(nlpsol_detect_bounds_before)
#define casadi_nlpsol_detect_bounds_data CASADI_PREFIX(nlpsol_detect_bounds_data)
#define casadi_nlpsol_detect_bounds_prob CASADI_PREFIX(nlpsol_detect_bounds_prob)
#define casadi_nlpsol_init CASADI_PREFIX(nlpsol_init)
#define casadi_nlpsol_prob CASADI_PREFIX(nlpsol_prob)
#define casadi_nlpsol_work CASADI_PREFIX(nlpsol_work)
#define casadi_oracle_data CASADI_PREFIX(oracle_data)
#define casadi_oracle_init CASADI_PREFIX(oracle_init)
#define casadi_project CASADI_PREFIX(project)
#define casadi_s0 CASADI_PREFIX(s0)
#define casadi_s1 CASADI_PREFIX(s1)
#define casadi_s10 CASADI_PREFIX(s10)
#define casadi_s11 CASADI_PREFIX(s11)
#define casadi_s12 CASADI_PREFIX(s12)
#define casadi_s13 CASADI_PREFIX(s13)
#define casadi_s2 CASADI_PREFIX(s2)
#define casadi_s3 CASADI_PREFIX(s3)
#define casadi_s4 CASADI_PREFIX(s4)
#define casadi_s5 CASADI_PREFIX(s5)
#define casadi_s6 CASADI_PREFIX(s6)
#define casadi_s7 CASADI_PREFIX(s7)
#define casadi_s8 CASADI_PREFIX(s8)
#define casadi_s9 CASADI_PREFIX(s9)
#define casadi_trans CASADI_PREFIX(trans)

/* Symbol visibility in DLLs */
#ifndef CASADI_SYMBOL_EXPORT
  #if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
    #if defined(STATIC_LINKED)
      #define CASADI_SYMBOL_EXPORT
    #else
      #define CASADI_SYMBOL_EXPORT __declspec(dllexport)
    #endif
  #elif defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
    #define CASADI_SYMBOL_EXPORT __attribute__ ((visibility ("default")))
  #else
    #define CASADI_SYMBOL_EXPORT
  #endif
#endif

void casadi_fill(casadi_real* x, casadi_int n, casadi_real alpha) {
  casadi_int i;
  if (x) {
    for (i=0; i<n; ++i) *x++ = alpha;
  }
}

struct casadi_oracle_data {
  const casadi_real** arg;
  casadi_real** res;
  casadi_int* iw;
  casadi_real* w;
  void* m;
};
void casadi_oracle_init(struct casadi_oracle_data* d, const casadi_real*** arg, casadi_real*** res,
    casadi_int** iw, casadi_real** w) {
  d->arg = *arg;
  d->res = *res;
  d->iw = *iw;
  d->w = *w;
}

struct casadi_nlpsol_detect_bounds_prob {
  casadi_int sz_arg;
  casadi_int sz_res;
  casadi_int sz_iw;
  casadi_int sz_w;
  casadi_int ng;
  casadi_int nb;
  const casadi_int *target_x;
  const casadi_int *target_g;
  const char *is_simple;
  int (*callback)(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, void* callback_data);
  void* callback_data;
};
struct casadi_nlpsol_prob {
  casadi_int nx, ng, np;
  struct casadi_nlpsol_detect_bounds_prob detect_bounds;
};
struct casadi_nlpsol_detect_bounds_data {
  const casadi_real** arg;
  casadi_real** res;
  casadi_int* iw;
  casadi_real* w;
  casadi_real* a;
  casadi_real* b;
  casadi_int* target_l;
  casadi_int* target_u;
  casadi_real* lam_xl;
  casadi_real* lam_xu;
};
struct casadi_nlpsol_data {
  const struct casadi_nlpsol_prob* prob;
  struct casadi_oracle_data* oracle;
  casadi_real *lbz, *ubz;
  casadi_real *z;
  casadi_real *lam;
  casadi_real objective;
  const casadi_real *p, *lbx, *ubx, *lbg, *ubg, *x0, *lam_x0, *lam_g0;
  casadi_real *f, *x, *g, *lam_x, *lam_g, *lam_p;
  struct casadi_nlpsol_detect_bounds_data detect_bounds;
};
void casadi_nlpsol_work(const struct casadi_nlpsol_prob* p, casadi_int* sz_arg, casadi_int* sz_res,
    casadi_int* sz_iw, casadi_int* sz_w) {
  *sz_arg = *sz_res = 0;
  *sz_w = *sz_iw = 0;
  *sz_w += p->nx + p->ng;
  *sz_w += p->nx + p->ng;
  *sz_w += p->nx + p->ng;
  *sz_w += p->nx + p->ng;
  if (p->detect_bounds.ng) {
    *sz_arg += p->detect_bounds.sz_arg;
    *sz_res += p->detect_bounds.sz_res;
    *sz_iw += p->detect_bounds.sz_iw;
    *sz_w += p->detect_bounds.sz_w;
    *sz_w += p->detect_bounds.nb;
    *sz_w += p->detect_bounds.nb;
    *sz_iw += p->nx;
    *sz_iw += p->nx;
    *sz_w += p->nx;
    *sz_w += p->nx;
  }
}
void casadi_nlpsol_init(struct casadi_nlpsol_data* d, const casadi_real*** arg, casadi_real*** res,
    casadi_int** iw, casadi_real** w) {
  casadi_int nx, ng;
  const struct casadi_nlpsol_prob* p = d->prob;
  nx = p->nx;
  ng = p->ng;
  d->z = *w; *w += nx + ng;
  d->lbz = *w; *w += nx + ng;
  d->ubz = *w; *w += nx + ng;
  d->lam = *w; *w += nx + ng;
  if (p->detect_bounds.ng) {
    d->detect_bounds.arg = *arg; *arg += p->detect_bounds.sz_arg;
    d->detect_bounds.res = *res; *res += p->detect_bounds.sz_res;
    d->detect_bounds.iw = *iw; *iw += p->detect_bounds.sz_iw;
    d->detect_bounds.w = *w; *w += p->detect_bounds.sz_w;
    d->detect_bounds.a = *w; *w += p->detect_bounds.nb;
    d->detect_bounds.b = *w; *w += p->detect_bounds.nb;
    d->detect_bounds.target_l = *iw; *iw += p->nx;
    d->detect_bounds.target_u = *iw; *iw += p->nx;
    d->detect_bounds.lam_xl = *w; *w += nx;
    d->detect_bounds.lam_xu = *w; *w += nx;
  }
}
int casadi_detect_bounds_before(struct casadi_nlpsol_data* d_nlp) {
  const struct casadi_nlpsol_prob* p_nlp = d_nlp->prob;
  struct casadi_nlpsol_detect_bounds_data* d_bounds = &d_nlp->detect_bounds;
  const struct casadi_nlpsol_detect_bounds_prob* p_bounds = &p_nlp->detect_bounds;
  casadi_int nx = p_nlp->nx;
  d_bounds->arg[0] = d_nlp->p;
  d_bounds->res[0] = d_bounds->a;
  d_bounds->res[1] = d_bounds->b;
  p_bounds->callback(d_bounds->arg, d_bounds->res,
    d_bounds->iw, d_bounds->w, p_bounds->callback_data);
  for (casadi_int i=0;i<p_bounds->nb;++i) {
    if (d_bounds->a[i]==0) {
      casadi_int k = p_bounds->target_g[i];
      if (d_nlp->lbg[k]>d_bounds->b[i]) return 1;
      if (d_nlp->ubg[k]<d_bounds->b[i]) return 1;
    }
  }
  casadi_real* lbz = d_nlp->lbz+nx;
  casadi_real* ubz = d_nlp->ubz+nx;
  casadi_real* lam = d_nlp->lam+nx;
  for (casadi_int i=0;i<nx;++i) {
    d_bounds->lam_xl[i] = d_nlp->lam_x0 ? (d_nlp->lam_x0[i]<0)*d_nlp->lam_x0[i] : 0.;
    d_bounds->lam_xu[i] = d_nlp->lam_x0 ? (d_nlp->lam_x0[i]>0)*d_nlp->lam_x0[i] : 0.;
  }
  for (casadi_int i=0;i<nx;++i) {
    d_bounds->target_l[i] = i;
    d_bounds->target_u[i] = i;
  }
  casadi_int k=0;
  for (casadi_int i=0;i<p_bounds->ng;++i) {
    if (p_bounds->is_simple[i]) {
      casadi_real lb = (d_nlp->lbg[i]-d_bounds->b[k])/d_bounds->a[k];
      casadi_real ub = (d_nlp->ubg[i]-d_bounds->b[k])/d_bounds->a[k];
      if (d_bounds->a[k]<0) {
        casadi_real tmp = lb;
        lb = ub;
        ub = tmp;
      }
      casadi_int j = p_bounds->target_x[k];
      if (lb==d_nlp->lbz[j]) {
        if (d_nlp->lam_g0) d_bounds->lam_xl[j] += (d_nlp->lam_g0[i]<0)*d_nlp->lam_g0[i];
      } else if (lb>d_nlp->lbz[j]) {
        d_nlp->lbz[j] = lb;
        d_bounds->target_l[j] = nx+i;
        if (d_nlp->lam_g0) d_bounds->lam_xl[j] = (d_nlp->lam_g0[i]<0)*d_nlp->lam_g0[i];
      }
      if (ub==d_nlp->ubz[j]) {
        if (d_nlp->lam_g0) d_bounds->lam_xu[j] += (d_nlp->lam_g0[i]>0)*d_nlp->lam_g0[i];
      } else if (ub<d_nlp->ubz[j]) {
        d_nlp->ubz[j] = ub;
        d_bounds->target_u[j] = nx+i;
        if (d_nlp->lam_g0) d_bounds->lam_xu[j] = (d_nlp->lam_g0[i]>0)*d_nlp->lam_g0[i];
      }
      k++;
    } else {
      *lbz++ = d_nlp->lbg[i];
      *ubz++ = d_nlp->ubg[i];
      if (d_nlp->lam_g0) *lam++ = d_nlp->lam_g0[i];
    }
  }
  for (casadi_int i=0;i<nx;++i) {
    d_nlp->lam[i] = d_bounds->lam_xl[i]+d_bounds->lam_xu[i];
  }
  return 0;
}
int casadi_detect_bounds_after(struct casadi_nlpsol_data* d_nlp) {
  const struct casadi_nlpsol_prob* p_nlp = d_nlp->prob;
  struct casadi_nlpsol_detect_bounds_data* d_bounds = &d_nlp->detect_bounds;
  const struct casadi_nlpsol_detect_bounds_prob* p_bounds = &p_nlp->detect_bounds;
  casadi_int nx = p_nlp->nx;
  casadi_fill(d_nlp->lam_x, nx, 0.);
  casadi_fill(d_nlp->lam_g, p_bounds->ng, 0.);
  casadi_int k = 0;
  casadi_int k_normal = 0;
  for (casadi_int i=0;i<p_bounds->ng;++i) {
    if (p_bounds->is_simple[i]) {
      casadi_int j = p_bounds->target_x[k];
      if (d_nlp->g) d_nlp->g[i] = d_bounds->a[k]*d_nlp->z[j]+d_bounds->b[k];
      k++;
    } else {
      if (d_nlp->g) d_nlp->g[i] = d_nlp->z[nx+k_normal];
      if (d_nlp->lam_g) d_nlp->lam_g[i] = d_nlp->lam[nx+k_normal];
      k_normal++;
    }
  }
  for (casadi_int i=0;i<nx;++i) {
    if (d_bounds->target_l[i]<nx) {
      if (d_nlp->lam_x) d_nlp->lam_x[i] += (d_nlp->lam[i]<0)*d_nlp->lam[i];
    } else {
      if (d_nlp->lam_g)
        d_nlp->lam_g[d_bounds->target_l[i]-nx] += (d_nlp->lam[i]<0)*d_nlp->lam[i];
    }
    if (d_bounds->target_u[i]<nx) {
      if (d_nlp->lam_x) d_nlp->lam_x[i] += (d_nlp->lam[i]>0)*d_nlp->lam[i];
    } else {
      if (d_nlp->lam_g)
        d_nlp->lam_g[d_bounds->target_u[i]-nx] += (d_nlp->lam[i]>0)*d_nlp->lam[i];
    }
  }
  k = 0;
  for (casadi_int i=0;i<p_bounds->ng;++i) {
    if (p_bounds->is_simple[i]) {
      if (d_nlp->lam_g) d_nlp->lam_g[i] /= d_bounds->a[k];
      k++;
    }
  }
  return 0;
}

void casadi_copy(const casadi_real* x, casadi_int n, casadi_real* y) {
  casadi_int i;
  if (y) {
    if (x) {
      for (i=0; i<n; ++i) *y++ = *x++;
    } else {
      for (i=0; i<n; ++i) *y++ = 0.;
    }
  }
}

casadi_real casadi_fmax(casadi_real x, casadi_real y) {
/* Pre-c99 compatibility */
#if __STDC_VERSION__ < 199901L
  return x>y ? x : y;
#else
  return fmax(x, y);
#endif
}

void casadi_clear(casadi_real* x, casadi_int n) {
  casadi_int i;
  if (x) {
    for (i=0; i<n; ++i) *x++ = 0;
  }
}

void casadi_mtimes(const casadi_real* x, const casadi_int* sp_x, const casadi_real* y, const casadi_int* sp_y, casadi_real* z, const casadi_int* sp_z, casadi_real* w, casadi_int tr) {
  casadi_int ncol_x, ncol_y, ncol_z, cc;
  const casadi_int *colind_x, *row_x, *colind_y, *row_y, *colind_z, *row_z;
  ncol_x = sp_x[1];
  colind_x = sp_x+2; row_x = sp_x + 2 + ncol_x+1;
  ncol_y = sp_y[1];
  colind_y = sp_y+2; row_y = sp_y + 2 + ncol_y+1;
  ncol_z = sp_z[1];
  colind_z = sp_z+2; row_z = sp_z + 2 + ncol_z+1;
  if (tr) {
    for (cc=0; cc<ncol_z; ++cc) {
      casadi_int kk;
      for (kk=colind_y[cc]; kk<colind_y[cc+1]; ++kk) {
        w[row_y[kk]] = y[kk];
      }
      for (kk=colind_z[cc]; kk<colind_z[cc+1]; ++kk) {
        casadi_int kk1;
        casadi_int rr = row_z[kk];
        for (kk1=colind_x[rr]; kk1<colind_x[rr+1]; ++kk1) {
          z[kk] += x[kk1] * w[row_x[kk1]];
        }
      }
    }
  } else {
    for (cc=0; cc<ncol_y; ++cc) {
      casadi_int kk;
      for (kk=colind_z[cc]; kk<colind_z[cc+1]; ++kk) {
        w[row_z[kk]] = z[kk];
      }
      for (kk=colind_y[cc]; kk<colind_y[cc+1]; ++kk) {
        casadi_int kk1;
        casadi_int rr = row_y[kk];
        for (kk1=colind_x[rr]; kk1<colind_x[rr+1]; ++kk1) {
          w[row_x[kk1]] += x[kk1]*y[kk];
        }
      }
      for (kk=colind_z[cc]; kk<colind_z[cc+1]; ++kk) {
        z[kk] = w[row_z[kk]];
      }
    }
  }
}

void casadi_trans(const casadi_real* x, const casadi_int* sp_x, casadi_real* y,
    const casadi_int* sp_y, casadi_int* tmp) {
  casadi_int ncol_x, nnz_x, ncol_y, k;
  const casadi_int* row_x, *colind_y;
  ncol_x = sp_x[1];
  nnz_x = sp_x[2 + ncol_x];
  row_x = sp_x + 2 + ncol_x+1;
  ncol_y = sp_y[1];
  colind_y = sp_y+2;
  for (k=0; k<ncol_y; ++k) tmp[k] = colind_y[k];
  for (k=0; k<nnz_x; ++k) {
    y[tmp[row_x[k]]++] = x[k];
  }
}

void casadi_project(const casadi_real* x, const casadi_int* sp_x, casadi_real* y, const casadi_int* sp_y, casadi_real* w) {
  casadi_int ncol_x, ncol_y, i, el;
  const casadi_int *colind_x, *row_x, *colind_y, *row_y;
  ncol_x = sp_x[1];
  colind_x = sp_x+2; row_x = sp_x + 2 + ncol_x+1;
  ncol_y = sp_y[1];
  colind_y = sp_y+2; row_y = sp_y + 2 + ncol_y+1;
  for (i=0; i<ncol_x; ++i) {
    for (el=colind_y[i]; el<colind_y[i+1]; ++el) w[row_y[el]] = 0;
    for (el=colind_x[i]; el<colind_x[i+1]; ++el) w[row_x[el]] = x[el];
    for (el=colind_y[i]; el<colind_y[i+1]; ++el) y[el] = w[row_y[el]];
  }
}

struct casadi_ipopt_prob {
  const struct casadi_nlpsol_prob* nlp;
  const casadi_int *sp_h, *sp_a;
  casadi_int nnz_h, nnz_a;
  Eval_F_CB eval_f;
  Eval_G_CB eval_g;
  Eval_Grad_F_CB eval_grad_f;
  Eval_Jac_G_CB eval_jac_g;
  Eval_H_CB eval_h;
};
void casadi_ipopt_setup(struct casadi_ipopt_prob* p) {
  if (p->sp_h) {
    p->nnz_h = p->sp_h[2+p->sp_h[1]];
  } else {
    p->nnz_h = 0;
  }
  p->nnz_a = p->sp_a[2+p->sp_a[1]];
}
struct casadi_ipopt_data {
  const struct casadi_ipopt_prob* prob;
  struct casadi_nlpsol_data* nlp;
  IpoptProblem ipopt;
  const casadi_real** arg;
  casadi_real** res;
  casadi_int* iw;
  casadi_real* w;
  casadi_real *z_L, *z_U;
  enum ApplicationReturnStatus status;
  int unified_return_status;
  int success;
};
int ipopt_init_mem(struct casadi_ipopt_data* d) {
  return 0;
}
void ipopt_free_mem(struct casadi_ipopt_data* d) {
}
void casadi_ipopt_work(const struct casadi_ipopt_prob* p, casadi_int* sz_arg, casadi_int* sz_res, casadi_int* sz_iw, casadi_int* sz_w) {
  casadi_nlpsol_work(p->nlp, sz_arg, sz_res, sz_iw, sz_w);
  *sz_w += p->nlp->nx;
  *sz_w += p->nlp->nx;
}
void casadi_ipopt_init(struct casadi_ipopt_data* d, const casadi_real*** arg, casadi_real*** res, casadi_int** iw, casadi_real** w) {
  const struct casadi_ipopt_prob* p = d->prob;
  const struct casadi_nlpsol_prob* p_nlp = p->nlp;
  d->z_L = *w; *w += p_nlp->nx;
  d->z_U = *w; *w += p_nlp->nx;
  d->arg = *arg;
  d->res = *res;
  d->iw = *iw;
  d->w = *w;
}
void casadi_ipopt_presolve(struct casadi_ipopt_data* d) {
  const struct casadi_ipopt_prob* p = d->prob;
  const struct casadi_nlpsol_prob* p_nlp = p->nlp;
  const struct casadi_nlpsol_data* d_nlp = d->nlp;
  d->ipopt = CreateIpoptProblem(
                p_nlp->nx, (double *) d_nlp->lbz, (double *) d_nlp->ubz,
                p_nlp->ng, (double *) d_nlp->lbz+p_nlp->nx,
                           (double *) d_nlp->ubz+p_nlp->nx,
                p->nnz_a, p->nnz_h, 0,
                p->eval_f, p->eval_g, p->eval_grad_f,
                p->eval_jac_g, p->eval_h);
}
void casadi_ipopt_solve(struct casadi_ipopt_data* d) {
  const struct casadi_ipopt_prob* p = d->prob;
  const struct casadi_nlpsol_prob* p_nlp = p->nlp;
  struct casadi_nlpsol_data* d_nlp = d->nlp;
  d->unified_return_status = 1;
  for (casadi_int i=0; i<p_nlp->nx; ++i) {
    d->z_L[i] = casadi_fmax(0., -d_nlp->lam[i]);
    d->z_U[i] = casadi_fmax(0., d_nlp->lam[i]);
  }
  d->status = IpoptSolve(d->ipopt, d_nlp->z, d_nlp->z + p_nlp->nx, &d_nlp->objective, d_nlp->lam+p_nlp->nx, d->z_L, d->z_U, d);
  for (casadi_int i=0; i<p_nlp->nx; ++i) {
    d_nlp->lam[i] = d->z_U[i]-d->z_L[i];
  }
  FreeIpoptProblem(d->ipopt);
  if (d->status==Solve_Succeeded ||
      d->status==Solved_To_Acceptable_Level ||
      d->status==Feasible_Point_Found) {
        d->unified_return_status = 0;
  } else if (d->status==Maximum_Iterations_Exceeded) {
      d->unified_return_status = 2;
  }
  #if (IPOPT_VERSION_MAJOR > 3) || (IPOPT_VERSION_MAJOR == 3 && IPOPT_VERSION_MINOR >= 14)
    if (d->status==Maximum_WallTime_Exceeded) d->unified_return_status = 2;
  #endif
  d->success = (d->unified_return_status == 0);
}
void casadi_ipopt_sparsity(const casadi_int* sp, ipindex *iRow, ipindex *jCol) {
    casadi_int ncol = sp[1];
    const casadi_int* colind = sp+2;
    const casadi_int* row = colind+ncol+1;
    for (casadi_int cc=0; cc<ncol; ++cc) {
        for (casadi_int el=colind[cc]; el<colind[cc+1]; ++el) {
            *iRow++ = row[el];
            *jCol++ = cc;
        }
    }
}
bool casadi_ipopt_hess_l_empty(ipindex n, ipnumber *x, bool new_x, ipnumber obj_factor, ipindex m, ipnumber *lambda, bool new_lambda, ipindex nele_hess, ipindex *iRow, ipindex *jCol, ipnumber *values, UserDataPtr user_data) {
  return false;
}

static int casadi_f1_mem_counter = 0;
static int casadi_f1_unused_stack_counter = -1;
static int casadi_f1_unused_stack[CASADI_MAX_NUM_THREADS];
static struct casadi_ipopt_data casadi_f1_mem[CASADI_MAX_NUM_THREADS];

#ifndef casadi_inf
  #define casadi_inf INFINITY
#endif

static const casadi_int casadi_s0[10] = {6, 1, 0, 6, 0, 1, 2, 3, 4, 5};
static const casadi_int casadi_s1[5] = {3, 1, 0, 1, 0};
static const casadi_int casadi_s2[24] = {6, 3, 0, 6, 12, 18, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5};
static const casadi_int casadi_s3[9] = {5, 1, 0, 5, 0, 1, 2, 3, 4};
static const casadi_int casadi_s4[21] = {5, 3, 0, 5, 10, 15, 0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 0, 1, 2, 3, 4};
static const casadi_int casadi_s5[5] = {3, 1, 0, 1, 1};
static const casadi_int casadi_s6[5] = {3, 1, 0, 1, 2};
static const casadi_int casadi_s7[42] = {11, 6, 0, 6, 12, 18, 23, 28, 33, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 6, 7, 8, 9, 10, 6, 7, 8, 9, 10};
static const casadi_int casadi_s8[47] = {6, 11, 0, 3, 6, 9, 12, 15, 18, 21, 24, 27, 30, 33, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 3, 4, 5, 3, 4, 5, 3, 4, 5, 3, 4, 5, 3, 4, 5};
static const casadi_int casadi_s9[6] = {0, 2, 4, 1, 3, 5};
static const casadi_int casadi_s10[6] = {6, 8, 10, 7, 9, 11};
static const casadi_int casadi_s11[21] = {6, 6, 0, 2, 4, 6, 8, 10, 12, 0, 3, 1, 4, 2, 5, 0, 3, 1, 4, 2, 5};
static const casadi_int casadi_s12[18] = {6, 6, 0, 1, 2, 3, 5, 7, 9, 0, 1, 2, 0, 3, 1, 4, 2, 5};
static const casadi_int casadi_s13[5] = {1, 1, 0, 1, 0};

static const casadi_real casadi_c0[18] = {0., 0., 1., -1., 0., 0., 0., 0., 0., 0., 1., -1., 1., -1., 0., 0., 0., 0.};
static const casadi_real casadi_c1[15] = {0., 0., 1.7300000000000000e+00, -3.4700000000000002e+00, 1.7300000000000000e+00, 0., 0., 3., 0., -3., 1., -1., 0., 0., 0.};
static const casadi_real casadi_c2[6] = {1.2500000000000000e+00, -7.5000000000000000e-01, 1.2500000000000000e+00, -7.5000000000000000e-01, 1.2500000000000000e+00, -7.5000000000000000e-01};
static const casadi_real casadi_c3[5] = {5.0000000000000003e-02, 5.0000000000000003e-02, 1., 1., 1.};

/* nlp_f:(x[6],p[0])->(f) */
static int casadi_f2(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
  casadi_int i, j, k;
  casadi_real *rr, *ss, *tt;
  const casadi_real *cs;
  casadi_real w0, *w1=w+2, *w2=w+5;
  /* #0: @0 = 0 */
  w0 = 0.;
  /* #1: @1 = input[0][0] */
  casadi_copy(arg[0], 3, w1);
  /* #2: @2 = input[0][1] */
  casadi_copy(arg[0] ? arg[0]+3 : 0, 3, w2);
  /* #3: @1 = (@1-@2) */
  for (i=0, rr=w1, cs=w2; i<3; ++i) (*rr++) -= (*cs++);
  /* #4: @2 = @1' */
  casadi_copy(w1, 3, w2);
  /* #5: @0 = mac(@2,@1,@0) */
  for (i=0, rr=(&w0); i<1; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, ss=w2+j, tt=w1+i*3; k<3; ++k) *rr += ss[k*1]**tt++;
  /* #6: output[0][0] = @0 */
  if (res[0]) res[0][0] = w0;
  return 0;
}

/* nlp_grad_f:(x[6],p[0])->(f,grad_f_x[6]) */
static int casadi_f3(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
  casadi_int i, j, k;
  casadi_real *rr, *ss, *tt;
  const casadi_real *cs;
  casadi_real w0, *w1=w+2, *w2=w+5;
  /* #0: @0 = 0 */
  w0 = 0.;
  /* #1: @1 = input[0][0] */
  casadi_copy(arg[0], 3, w1);
  /* #2: @2 = input[0][1] */
  casadi_copy(arg[0] ? arg[0]+3 : 0, 3, w2);
  /* #3: @1 = (@1-@2) */
  for (i=0, rr=w1, cs=w2; i<3; ++i) (*rr++) -= (*cs++);
  /* #4: @2 = @1' */
  casadi_copy(w1, 3, w2);
  /* #5: @0 = mac(@2,@1,@0) */
  for (i=0, rr=(&w0); i<1; ++i) for (j=0; j<1; ++j, ++rr) for (k=0, ss=w2+j, tt=w1+i*3; k<3; ++k) *rr += ss[k*1]**tt++;
  /* #6: output[0][0] = @0 */
  if (res[0]) res[0][0] = w0;
  /* #7: @1 = (2.*@1) */
  for (i=0, rr=w1, cs=w1; i<3; ++i) *rr++ = (2.* *cs++ );
  /* #8: output[1][0] = @1 */
  casadi_copy(w1, 3, res[1]);
  /* #9: @1 = (-@1) */
  for (i=0, rr=w1, cs=w1; i<3; ++i) *rr++ = (- *cs++ );
  /* #10: output[1][1] = @1 */
  if (res[1]) casadi_copy(w1, 3, res[1]+3);
  return 0;
}

/* nlp_g:(x[6],p[0])->(g[11]) */
static int casadi_f4(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
  casadi_int i, j, k;
  casadi_real *rr, *ss, *tt;
  casadi_real *w0=w+6, *w1=w+12, *w2=w+30, *w3=w+33, *w4=w+38;
  /* #0: @0 = zeros(6x1) */
  casadi_clear(w0, 6);
  /* #1: @1 = 
  [[0, 0, 1], 
   [0, 0, -1], 
   [1, 0, 0], 
   [-1, 0, 0], 
   [0, 1, 0], 
   [0, -1, 0]] */
  casadi_copy(casadi_c0, 18, w1);
  /* #2: @2 = input[0][0] */
  casadi_copy(arg[0], 3, w2);
  /* #3: @0 = mac(@1,@2,@0) */
  for (i=0, rr=w0; i<1; ++i) for (j=0; j<6; ++j, ++rr) for (k=0, ss=w1+j, tt=w2+i*3; k<3; ++k) *rr += ss[k*6]**tt++;
  /* #4: output[0][0] = @0 */
  casadi_copy(w0, 6, res[0]);
  /* #5: @3 = zeros(5x1) */
  casadi_clear(w3, 5);
  /* #6: @4 = 
  [[0, 0, 1], 
   [0, 0, -1], 
   [1.73, 3, 0], 
   [-3.47, 0, 0], 
   [1.73, -3, 0]] */
  casadi_copy(casadi_c1, 15, w4);
  /* #7: @2 = input[0][1] */
  casadi_copy(arg[0] ? arg[0]+3 : 0, 3, w2);
  /* #8: @3 = mac(@4,@2,@3) */
  for (i=0, rr=w3; i<1; ++i) for (j=0; j<5; ++j, ++rr) for (k=0, ss=w4+j, tt=w2+i*3; k<3; ++k) *rr += ss[k*5]**tt++;
  /* #9: output[0][1] = @3 */
  if (res[0]) casadi_copy(w3, 5, res[0]+6);
  return 0;
}

/* nlp_jac_g:(x[6],p[0])->(g[11],jac_g_x[11x6,33nz]) */
static int casadi_f5(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
  casadi_int i, j, k;
  casadi_real *rr, *ss, *tt;
  const casadi_real *cs;
  casadi_real *w0=w+6, *w1=w+12, *w2=w+30, *w3=w+33, *w4=w+38, *w5=w+53, *w6=w+86, w7, w8, *w9=w+90, *w10=w+101;
  /* #0: @0 = zeros(6x1) */
  casadi_clear(w0, 6);
  /* #1: @1 = 
  [[0, 0, 1], 
   [0, 0, -1], 
   [1, 0, 0], 
   [-1, 0, 0], 
   [0, 1, 0], 
   [0, -1, 0]] */
  casadi_copy(casadi_c0, 18, w1);
  /* #2: @2 = input[0][0] */
  casadi_copy(arg[0], 3, w2);
  /* #3: @0 = mac(@1,@2,@0) */
  for (i=0, rr=w0; i<1; ++i) for (j=0; j<6; ++j, ++rr) for (k=0, ss=w1+j, tt=w2+i*3; k<3; ++k) *rr += ss[k*6]**tt++;
  /* #4: output[0][0] = @0 */
  casadi_copy(w0, 6, res[0]);
  /* #5: @3 = zeros(5x1) */
  casadi_clear(w3, 5);
  /* #6: @4 = 
  [[0, 0, 1], 
   [0, 0, -1], 
   [1.73, 3, 0], 
   [-3.47, 0, 0], 
   [1.73, -3, 0]] */
  casadi_copy(casadi_c1, 15, w4);
  /* #7: @2 = input[0][1] */
  casadi_copy(arg[0] ? arg[0]+3 : 0, 3, w2);
  /* #8: @3 = mac(@4,@2,@3) */
  for (i=0, rr=w3; i<1; ++i) for (j=0; j<5; ++j, ++rr) for (k=0, ss=w4+j, tt=w2+i*3; k<3; ++k) *rr += ss[k*5]**tt++;
  /* #9: output[0][1] = @3 */
  if (res[0]) casadi_copy(w3, 5, res[0]+6);
  /* #10: @5 = zeros(6x11,33nz) */
  casadi_clear(w5, 33);
  /* #11: @0 = zeros(6x1) */
  casadi_clear(w0, 6);
  /* #12: @6 = ones(6x1,2nz) */
  casadi_fill(w6, 2, 1.);
  /* #13: {@7, @8} = vertsplit(@6) */
  w7 = w6[0];
  w8 = w6[1];
  /* #14: @0 = mac(@1,@7,@0) */
  casadi_mtimes(w1, casadi_s2, (&w7), casadi_s1, w0, casadi_s0, w, 0);
  /* #15: @3 = zeros(5x1) */
  casadi_clear(w3, 5);
  /* #16: @3 = mac(@4,@8,@3) */
  casadi_mtimes(w4, casadi_s4, (&w8), casadi_s1, w3, casadi_s3, w, 0);
  /* #17: @9 = vertcat(@0, @3) */
  rr=w9;
  for (i=0, cs=w0; i<6; ++i) *rr++ = *cs++;
  for (i=0, cs=w3; i<5; ++i) *rr++ = *cs++;
  /* #18: (@5[:33:3] = @9) */
  for (rr=w5+0, ss=w9; rr!=w5+33; rr+=3) *rr = *ss++;
  /* #19: @0 = zeros(6x1) */
  casadi_clear(w0, 6);
  /* #20: @6 = ones(6x1,2nz) */
  casadi_fill(w6, 2, 1.);
  /* #21: {@8, @7} = vertsplit(@6) */
  w8 = w6[0];
  w7 = w6[1];
  /* #22: @0 = mac(@1,@8,@0) */
  casadi_mtimes(w1, casadi_s2, (&w8), casadi_s5, w0, casadi_s0, w, 0);
  /* #23: @3 = zeros(5x1) */
  casadi_clear(w3, 5);
  /* #24: @3 = mac(@4,@7,@3) */
  casadi_mtimes(w4, casadi_s4, (&w7), casadi_s5, w3, casadi_s3, w, 0);
  /* #25: @9 = vertcat(@0, @3) */
  rr=w9;
  for (i=0, cs=w0; i<6; ++i) *rr++ = *cs++;
  for (i=0, cs=w3; i<5; ++i) *rr++ = *cs++;
  /* #26: (@5[1:34:3] = @9) */
  for (rr=w5+1, ss=w9; rr!=w5+34; rr+=3) *rr = *ss++;
  /* #27: @0 = zeros(6x1) */
  casadi_clear(w0, 6);
  /* #28: @6 = ones(6x1,2nz) */
  casadi_fill(w6, 2, 1.);
  /* #29: {@7, @8} = vertsplit(@6) */
  w7 = w6[0];
  w8 = w6[1];
  /* #30: @0 = mac(@1,@7,@0) */
  casadi_mtimes(w1, casadi_s2, (&w7), casadi_s6, w0, casadi_s0, w, 0);
  /* #31: @3 = zeros(5x1) */
  casadi_clear(w3, 5);
  /* #32: @3 = mac(@4,@8,@3) */
  casadi_mtimes(w4, casadi_s4, (&w8), casadi_s6, w3, casadi_s3, w, 0);
  /* #33: @9 = vertcat(@0, @3) */
  rr=w9;
  for (i=0, cs=w0; i<6; ++i) *rr++ = *cs++;
  for (i=0, cs=w3; i<5; ++i) *rr++ = *cs++;
  /* #34: (@5[2:35:3] = @9) */
  for (rr=w5+2, ss=w9; rr!=w5+35; rr+=3) *rr = *ss++;
  /* #35: @10 = @5' */
  casadi_trans(w5,casadi_s8, w10, casadi_s7, iw);
  /* #36: output[1][0] = @10 */
  casadi_copy(w10, 33, res[1]);
  return 0;
}

/* nlp_hess_l:(x[6],p[0],lam_f,lam_g[11])->(triu_hess_gamma_x_x[6x6,9nz]) */
static int casadi_f6(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
  casadi_int i;
  casadi_real *rr, *ss;
  const casadi_int *cii;
  const casadi_real *cs;
  casadi_real *w0=w+6, w1, *w2=w+19, *w3=w+22, *w4=w+25, *w5=w+31, *w6=w+43;
  /* #0: @0 = zeros(6x6,12nz) */
  casadi_clear(w0, 12);
  /* #1: @1 = input[2][0] */
  w1 = arg[2] ? arg[2][0] : 0;
  /* #2: @2 = ones(6x1,3nz) */
  casadi_fill(w2, 3, 1.);
  /* #3: {@3, NULL} = vertsplit(@2) */
  casadi_copy(w2, 3, w3);
  /* #4: @2 = (@1*@3) */
  for (i=0, rr=w2, cs=w3; i<3; ++i) (*rr++)  = (w1*(*cs++));
  /* #5: @3 = @3' */
  /* #6: @3 = (@1*@3) */
  for (i=0, rr=w3, cs=w3; i<3; ++i) (*rr++)  = (w1*(*cs++));
  /* #7: @3 = @3' */
  /* #8: @2 = (@2+@3) */
  for (i=0, rr=w2, cs=w3; i<3; ++i) (*rr++) += (*cs++);
  /* #9: @3 = (-@2) */
  for (i=0, rr=w3, cs=w2; i<3; ++i) *rr++ = (- *cs++ );
  /* #10: @4 = vertcat(@2, @3) */
  rr=w4;
  for (i=0, cs=w2; i<3; ++i) *rr++ = *cs++;
  for (i=0, cs=w3; i<3; ++i) *rr++ = *cs++;
  /* #11: (@0[0, 2, 4, 1, 3, 5] = @4) */
  for (cii=casadi_s9, rr=w0, ss=w4; cii!=casadi_s9+6; ++cii, ++ss) rr[*cii] = *ss;
  /* #12: (@0[:12:2] = @4) */
  for (rr=w0+0, ss=w4; rr!=w0+12; rr+=2) *rr = *ss++;
  /* #13: @2 = ones(6x1,3nz) */
  casadi_fill(w2, 3, 1.);
  /* #14: {NULL, @3} = vertsplit(@2) */
  casadi_copy(w2, 3, w3);
  /* #15: @2 = (-@3) */
  for (i=0, rr=w2, cs=w3; i<3; ++i) *rr++ = (- *cs++ );
  /* #16: @2 = @2' */
  /* #17: @2 = (@1*@2) */
  for (i=0, rr=w2, cs=w2; i<3; ++i) (*rr++)  = (w1*(*cs++));
  /* #18: @2 = @2' */
  /* #19: @3 = (@1*@3) */
  for (i=0, rr=w3, cs=w3; i<3; ++i) (*rr++)  = (w1*(*cs++));
  /* #20: @2 = (@2-@3) */
  for (i=0, rr=w2, cs=w3; i<3; ++i) (*rr++) -= (*cs++);
  /* #21: @3 = (-@2) */
  for (i=0, rr=w3, cs=w2; i<3; ++i) *rr++ = (- *cs++ );
  /* #22: @4 = vertcat(@2, @3) */
  rr=w4;
  for (i=0, cs=w2; i<3; ++i) *rr++ = *cs++;
  for (i=0, cs=w3; i<3; ++i) *rr++ = *cs++;
  /* #23: (@0[6, 8, 10, 7, 9, 11] = @4) */
  for (cii=casadi_s10, rr=w0, ss=w4; cii!=casadi_s10+6; ++cii, ++ss) rr[*cii] = *ss;
  /* #24: (@0[1:13:2] = @4) */
  for (rr=w0+1, ss=w4; rr!=w0+13; rr+=2) *rr = *ss++;
  /* #25: @5 = @0' */
  casadi_trans(w0,casadi_s11, w5, casadi_s11, iw);
  /* #26: @6 = project(@5) */
  casadi_project(w5, casadi_s11, w6, casadi_s12, w);
  /* #27: output[0][0] = @6 */
  casadi_copy(w6, 9, res[0]);
  return 0;
}

bool casadi_nlp_f0(ipindex n, ipnumber *x, bool new_x, ipnumber *obj_value, UserDataPtr user_data) {
  struct casadi_ipopt_data* d = (struct casadi_ipopt_data*) user_data;
  d->arg[0] = x;
  d->arg[1] = d->nlp->p;
  d->res[0] = obj_value;
  if (casadi_f2(d->arg, d->res, d->iw, d->w, 0)) return false;
  return true;
}
bool casadi_nlp_g0(ipindex n, ipnumber *x, bool new_x, ipindex m, ipnumber *g, UserDataPtr user_data) {
  struct casadi_ipopt_data* d = (struct casadi_ipopt_data*) user_data;
  d->arg[0] = x;
  d->arg[1] = d->nlp->p;
  d->res[0] = g;
  if (casadi_f4(d->arg, d->res, d->iw, d->w, 0)) return false;
  return true;
}
bool casadi_nlp_grad_f0(ipindex n, ipnumber *x, bool new_x, ipnumber *grad_f, UserDataPtr user_data) {
  struct casadi_ipopt_data* d = (struct casadi_ipopt_data*) user_data;
  d->arg[0] = x;
  d->arg[1] = d->nlp->p;
  d->res[0] = 0;
  d->res[1] = grad_f;
  if (casadi_f3(d->arg, d->res, d->iw, d->w, 0)) return false;
  return true;
}
bool casadi_nlp_jac_g0(ipindex n, ipnumber *x, bool new_x, ipindex m, ipindex nele_jac, ipindex *iRow, ipindex *jCol, ipnumber *values, UserDataPtr user_data) {
  struct casadi_ipopt_data* d = (struct casadi_ipopt_data*) user_data;
  if (values) {
    d->arg[0] = x;
    d->arg[1] = d->nlp->p;
    d->res[0] = 0;
    d->res[1] = values;
    if (casadi_f5(d->arg, d->res, d->iw, d->w, 0)) return false;
  } else {
    casadi_ipopt_sparsity(d->prob->sp_a, iRow, jCol);
  }
  return true;
}
bool casadi_nlp_hess_l0(ipindex n, ipnumber *x, bool new_x, ipnumber obj_factor,ipindex m, ipnumber *lambda, bool new_lambda, ipindex nele_hess, ipindex *iRow, ipindex *jCol, ipnumber *values, UserDataPtr user_data) {
  struct casadi_ipopt_data* d = (struct casadi_ipopt_data*) user_data;
  if (values) {
    d->arg[0] = x;
    d->arg[1] = d->nlp->p;
    d->arg[2] = &obj_factor;
    d->arg[3] = lambda;
    d->res[0] = values;
    if (casadi_f6(d->arg, d->res, d->iw, d->w, 0)) return false;
    return true;
  } else {
    casadi_ipopt_sparsity(d->prob->sp_h, iRow, jCol);
  }
  return true;
}
/* solver:(x0[6],p[0],lbx[6],ubx[6],lbg[11],ubg[11],lam_x0[6],lam_g0[11])->(x[6],f,g[11],lam_x[6],lam_g[11],lam_p[0]) */
static int casadi_f1(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
  struct casadi_ipopt_data* d=&casadi_f1_mem[mem];
  struct casadi_ipopt_prob p;
  struct casadi_nlpsol_data d_nlp;
  struct casadi_nlpsol_prob p_nlp;
  struct casadi_oracle_data d_oracle;
  d_nlp.oracle = &d_oracle;
  d_nlp.p = arg[1];
  d_nlp.lbx = arg[2];
  d_nlp.ubx = arg[3];
  d_nlp.lbg = arg[4];
  d_nlp.ubg = arg[5];
  d_nlp.x0 = arg[0];
  d_nlp.lam_x0 = arg[6];
  d_nlp.lam_g0 = arg[7];
  d_nlp.x = res[0];
  d_nlp.f = res[1];
  d_nlp.g = res[2];
  d_nlp.lam_x = res[3];
  d_nlp.lam_g = res[4];
  d_nlp.lam_p = res[5];
  d_nlp.prob = &p_nlp;
  p_nlp.nx = 6;
  p_nlp.ng = 11;
  p_nlp.np = 0;
  p_nlp.detect_bounds.ng = 0;
  casadi_nlpsol_init(&d_nlp, &arg, &res, &iw, &w);
  if (d_nlp.x0) {
    casadi_copy(d_nlp.x0, 6, d_nlp.z);
  } else {
    casadi_clear(d_nlp.z, 6);
  }
  if (d_nlp.lbx) {
    casadi_copy(d_nlp.lbx, 6, d_nlp.lbz);
  } else {
    casadi_fill(d_nlp.lbz, 6, -casadi_inf);
  }
  if (d_nlp.ubx) {
    casadi_copy(d_nlp.ubx, 6, d_nlp.ubz);
  } else {
    casadi_fill(d_nlp.ubz, 6, casadi_inf);
  }
  if (d_nlp.lam_x0) {
    casadi_copy(d_nlp.lam_x0, 6, d_nlp.lam);
  } else {
    casadi_clear(d_nlp.lam, 6);
  }
  if (d_nlp.lbg) {
    casadi_copy(d_nlp.lbg, 11, d_nlp.lbz+6);
  } else {
    casadi_fill(d_nlp.lbz+6, 11, -casadi_inf);
  }
  if (d_nlp.ubg) {
    casadi_copy(d_nlp.ubg, 11, d_nlp.ubz+6);
  } else {
    casadi_fill(d_nlp.ubz+6, 11, casadi_inf);
  }
  if (d_nlp.lam_g0) {
    casadi_copy(d_nlp.lam_g0, 11, d_nlp.lam+6);
  } else {
    casadi_clear(d_nlp.lam+6, 11);
  }
  d->nlp = &d_nlp;
  d->prob = &p;
  p.nlp = &p_nlp;
  p.sp_a = casadi_s7;
  p.sp_h = casadi_s12;
  casadi_ipopt_setup(&p);
  p.eval_f = casadi_nlp_f0;
  p.eval_g = casadi_nlp_g0;
  p.eval_grad_f = casadi_nlp_grad_f0;
  p.eval_jac_g = casadi_nlp_jac_g0;
  p.eval_h = casadi_nlp_hess_l0;
  casadi_ipopt_init(d, &arg, &res, &iw, &w);
  casadi_ipopt_presolve(d);
  AddIpoptIntOption(d->ipopt, "print_level",0);
  AddIpoptStrOption(d->ipopt, "linear_solver","mumps");
  casadi_ipopt_solve(d);
  casadi_copy(d_nlp.z, 6, d_nlp.x);
  casadi_copy(d_nlp.z + 6, 11, d_nlp.g);
  casadi_copy(d_nlp.lam, 6, d_nlp.lam_x);
  casadi_copy(d_nlp.lam + 6, 11, d_nlp.lam_g);
  if (d_nlp.f) casadi_copy(&d_nlp.objective, 1, d_nlp.f);
  if (d_nlp.lam_p) casadi_copy(d_nlp.lam_p, 0, d_nlp.lam_p);
  return 0;
  return 0;
}

int casadi_f1_alloc_mem(void) {
  return casadi_f1_mem_counter++;
}

int casadi_f1_init_mem(int mem) {
  ipopt_init_mem(&casadi_f1_mem[mem]);
  return 0;
}

void casadi_f1_free_mem(int mem) {
  ipopt_free_mem(&casadi_f1_mem[mem]);
}

int casadi_f1_checkout(void) {
  int mid;
  if (casadi_f1_unused_stack_counter>=0) {
    return casadi_f1_unused_stack[casadi_f1_unused_stack_counter--];
  } else {
    if (casadi_f1_mem_counter==CASADI_MAX_NUM_THREADS) return -1;
    mid = casadi_f1_alloc_mem();
    if (mid<0) return -1;
    if(casadi_f1_init_mem(mid)) return -1;
    return mid;
  }
}

void casadi_f1_release(int mem) {
  casadi_f1_unused_stack[++casadi_f1_unused_stack_counter] = mem;
}

/* helper:(i0[6],i1[0],i2[11])->(o0) */
static int casadi_f7(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
  casadi_real w0;
  /* #0: @0 = 1.01545 */
  w0 = 1.0154472668069912e+00;
  /* #1: output[0][0] = @0 */
  if (res[0]) res[0][0] = w0;
  return 0;
}

/* solver:()->(o0) */
static int casadi_f0(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
  casadi_int i;
  casadi_real **res1=res+1, *rr;
  const casadi_real **arg1=arg+0, *cs;
  int flag, mid;
  casadi_real *w0=w+261, *w2=w+267, *w3=w+273, *w4=w+279, *w5=w+290, *w6=w+296, *w7=w+301, *w8=w+312, *w9=w+323, *w10=w+329, w11;
  /* #0: @0 = zeros(6x1) */
  casadi_clear(w0, 6);
  /* #1: @1 = 0x1 */
  /* #2: @2 = -inf(6x1) */
  casadi_fill(w2, 6, -casadi_inf);
  /* #3: @3 = inf(6x1) */
  casadi_fill(w3, 6, casadi_inf);
  /* #4: @4 = -inf(11x1) */
  casadi_fill(w4, 11, -casadi_inf);
  /* #5: @5 = [1.25, -0.75, 1.25, -0.75, 1.25, -0.75] */
  casadi_copy(casadi_c2, 6, w5);
  /* #6: @6 = [0.05, 0.05, 1, 1, 1] */
  casadi_copy(casadi_c3, 5, w6);
  /* #7: @7 = vertcat(@5, @6) */
  rr=w7;
  for (i=0, cs=w5; i<6; ++i) *rr++ = *cs++;
  for (i=0, cs=w6; i<5; ++i) *rr++ = *cs++;
  /* #8: @5 = zeros(6x1) */
  casadi_clear(w5, 6);
  /* #9: @8 = zeros(11x1) */
  casadi_clear(w8, 11);
  /* #10: {@9, NULL, NULL, NULL, @10, NULL} = solver(@0, @1, @2, @3, @4, @7, @5, @8) */
  arg1[0]=w0;
  arg1[1]=0;
  arg1[2]=w2;
  arg1[3]=w3;
  arg1[4]=w4;
  arg1[5]=w7;
  arg1[6]=w5;
  arg1[7]=w8;
  res1[0]=w9;
  res1[1]=0;
  res1[2]=0;
  res1[3]=0;
  res1[4]=w10;
  res1[5]=0;
  mid = casadi_f1_checkout();
  if (mid<0) return 1;
  flag = casadi_f1(arg1, res1, iw, w, mid);
  casadi_f1_release(mid);
  if (flag) return 1;
  /* #11: @11 = helper(@9, @1, @10) */
  arg1[0]=w9;
  arg1[1]=0;
  arg1[2]=w10;
  res1[0]=(&w11);
  if (casadi_f7(arg1, res1, iw, w, 0)) return 1;
  /* #12: output[0][0] = @11 */
  if (res[0]) res[0][0] = w11;
  return 0;
}

CASADI_SYMBOL_EXPORT int solver(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem){
  return casadi_f0(arg, res, iw, w, mem);
}

CASADI_SYMBOL_EXPORT int solver_alloc_mem(void) {
  return 0;
}

CASADI_SYMBOL_EXPORT int solver_init_mem(int mem) {
  return 0;
}

CASADI_SYMBOL_EXPORT void solver_free_mem(int mem) {
}

CASADI_SYMBOL_EXPORT int solver_checkout(void) {
  return 0;
}

CASADI_SYMBOL_EXPORT void solver_release(int mem) {
}

CASADI_SYMBOL_EXPORT void solver_incref(void) {
}

CASADI_SYMBOL_EXPORT void solver_decref(void) {
}

CASADI_SYMBOL_EXPORT casadi_int solver_n_in(void) { return 0;}

CASADI_SYMBOL_EXPORT casadi_int solver_n_out(void) { return 1;}

CASADI_SYMBOL_EXPORT casadi_real solver_default_in(casadi_int i) {
  switch (i) {
    default: return 0;
  }
}

CASADI_SYMBOL_EXPORT const char* solver_name_in(casadi_int i) {
  switch (i) {
    default: return 0;
  }
}

CASADI_SYMBOL_EXPORT const char* solver_name_out(casadi_int i) {
  switch (i) {
    case 0: return "o0";
    default: return 0;
  }
}

CASADI_SYMBOL_EXPORT const casadi_int* solver_sparsity_in(casadi_int i) {
  switch (i) {
    default: return 0;
  }
}

CASADI_SYMBOL_EXPORT const casadi_int* solver_sparsity_out(casadi_int i) {
  switch (i) {
    case 0: return casadi_s13;
    default: return 0;
  }
}

CASADI_SYMBOL_EXPORT int solver_work(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w) {
  if (sz_arg) *sz_arg = 15;
  if (sz_res) *sz_res = 13;
  if (sz_iw) *sz_iw = 7;
  if (sz_w) *sz_w = 341;
  return 0;
}

CASADI_SYMBOL_EXPORT int solver_work_bytes(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w) {
  if (sz_arg) *sz_arg = 15*sizeof(const casadi_real*);
  if (sz_res) *sz_res = 13*sizeof(casadi_real*);
  if (sz_iw) *sz_iw = 7*sizeof(casadi_int);
  if (sz_w) *sz_w = 341*sizeof(casadi_real);
  return 0;
}


#ifdef __cplusplus
} /* extern "C" */
#endif
